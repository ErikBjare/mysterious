%class "LangParser";
%package "lang.ast";

%embed {:
    static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
    // Disable syntax error recovery
    protected void recoverFromError(Symbol token, TokenStream in) {
        throw new SyntaxError("Cannot recover from the syntax error");
    }
:};

%terminals ID, TYPE, LEFTP, RIGHTP, LEFTB, RIGHTB, EQ, LITERAL, SEMIC, MUL, PLUS, MOD, MINUS, COMMA, WHILE, IF, ELSE, FOR;

%typeof program = "Program";
%typeof function = "Function";
%typeof function_list = "List";
%typeof stmts = "List";
%typeof stmt = "Stmt";
%typeof id_decl = "IdDecl";
%typeof assign = "Assign";
%typeof expr = "Expr";
%typeof literal = "Literal";
%typeof id_use = "IdUse";
%typeof term = "Expr";
%typeof factor = "Expr";

%typeof parameter_list = "List";
%typeof nonempty_parameter_list = "List";

%typeof function_call = "Expr";
%typeof expr_list = "List";
%typeof nonempty_expr_list = "List";

%typeof if_stmt = "Stmt";
%typeof if_block = "Stmt";
%typeof else_if_blocks = "List";
%typeof else_block = "Stmt";
%typeof else_stmt = "Opt";

%typeof while_stmt = "Stmt";

%typeof for_stmt = "Stmt";
%typeof opt_expr = "Opt";


%goal program;

program = function_list.fl {: return new Program(fl); :} ;

function_list =
    function.f {: return new List().add(f); :}
    | function_list.fl function.f {: return fl.add(f); :}
    ;

function = TYPE.t id_use.id LEFTP parameter_list.params RIGHTP LEFTB stmts.cmds RIGHTB {: return new Function(id, t, params, cmds); :} ;

parameter_list =
    /* epsilon */ {: return new List(); :}
    | nonempty_parameter_list.list {: return list; :} ;

nonempty_parameter_list =
    id_decl.p {: return new List().add(p); :}
    | id_decl.p COMMA nonempty_parameter_list.list {: return list.add(p); :} ;

stmt =
    id_decl.s SEMIC {: return s; :}
    | assign.s SEMIC {: return s; :}
    | if_stmt.s SEMIC {: return s; :}
    | while_stmt.s SEMIC {: return s; :}
    | for_stmt.f {: return f; :}
    ;

stmts =
    {: return new List(); :}
    | stmt.s stmts.list {: return list.add(s); :}
    ;

for_stmt =
    FOR LEFTP opt_expr.a SEMIC opt_expr.b SEMIC opt_expr.c LEFTB stmts.cmds RIGHTB
    {: return new ForStmt(a, b, c, cmds); :}
    ;

opt_expr =
    {: return new Opt(); :}
    | expr.e {: return new Opt(e); :}
    ;

id_decl = TYPE.t id_use.id {: return new IdDecl(t,id); :} ;

assign = id_use.id EQ expr.e {: return new Assign(id,e); :} ;

factor =
    literal.l {: return l; :}
    | id_use.id {: return id; :}
    | function_call.f {: return f; :}
    ;

term =
    factor.f {: return f; :}
    | factor.f MUL term.t {: return new Mul(f,t); :}
    | factor.f MOD term.t {: return new Mod(f,t); :}
    ;

expr =
    expr.e PLUS term.t {: return new Add(e,t); :}
    | expr.e MINUS term.t {: return new Sub(e,t); :}
    | term.t {: return t; :}
    ;

literal = LITERAL.l {: return new Literal(l); :} ;

id_use = ID.id {: return new IdUse(id); :} ;

function_call =
    id_use.id LEFTP expr_list.list RIGHTP {: return new FunctionCall(id,list); :}
    ;

expr_list =
    {: return new List(); :}
    | nonempty_expr_list.list {: return list; :}
    ;

nonempty_expr_list =
    expr.e {: return new List().add(e); :}
    | nonempty_expr_list.list COMMA expr.e {: return list.add(e); :}
    ;

if_stmt = 
    if_block.i else_if_blocks.ie else_stmt.e {: return new IfStmt(i, ie, e); :} ;


if_block =
    IF LEFTP expr.expr RIGHTP LEFTB stmts.stmts RIGHTB {: return new IfBlock(expr, stmts); :}
    ;

else_if_blocks = 
    {: return new List(); :}
    | else_if_blocks.list ELSE if_block.b {: return list.add(b); :} 
    ; 

else_stmt = 
    {: return new Opt(); :}
    | else_block.eb {: return new Opt(eb); :}
    ;
else_block = 
    ELSE LEFTB stmts.stmts RIGHTB {: return new ElseBlock(stmts); :}
    ;
    

while_stmt =
    WHILE LEFTP expr.expr RIGHTP LEFTB stmts.stmts RIGHTB {: return new WhileStmt(expr, stmts); :}
    ;

